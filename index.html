<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimizador de Impresión</title>
    
    <!-- Icono de Impresora en la pestaña -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22%232563eb%22 stroke-width=%222%22 stroke-linecap=%22round%22 stroke-linejoin=%22round%22><polyline points=%226 9 6 2 18 2 18 9%22></polyline><path d=%22M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2%22></path><rect x=%226%22 y=%2214%22 width=%2212%22 height=%228%22></rect></svg>">
    
    <!-- 1. Cargar Tailwind CSS (Estilos) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Cargar React y ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 3. Cargar Babel (Para entender el código moderno) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 4. Cargar jsPDF (Para generar el PDF) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* Estilos extra */
        .grid-bg { background-image: linear-gradient(#e5e7eb 1px, transparent 1px), linear-gradient(90deg, #e5e7eb 1px, transparent 1px); }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #2563eb; cursor: pointer; margin-top: -6px; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #cbd5e1; border-radius: 2px; }
        
        /* Cursor para recorte y resize */
        .crosshair-cursor { cursor: crosshair; }
        .resize-handle { width: 10px; height: 10px; background: white; border: 1px solid #2563eb; position: absolute; z-index: 60; }
        .resize-nw { cursor: nw-resize; top: -5px; left: -5px; }
        .resize-ne { cursor: ne-resize; top: -5px; right: -5px; }
        .resize-sw { cursor: sw-resize; bottom: -5px; left: -5px; }
        .resize-se { cursor: se-resize; bottom: -5px; right: -5px; }
    </style>
</head>
<body class="bg-gray-100 h-screen overflow-hidden">
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- ICONOS SVG ---
        const IconUpload = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>;
        const IconFileDown = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="m9 15 3 3 3-3"/></svg>;
        const IconSettings = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
        const IconTrash = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>;
        const IconCheck = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"/></svg>;
        const IconMove = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="19 9 22 12 19 15"/><polyline points="9 19 12 22 15 19"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></svg>;
        const IconPlus = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>;
        const IconRuler = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z"/><line x1="14.5" y1="12.5" x2="18" y2="16"/><line x1="11.5" y1="9.5" x2="15" y2="13"/><line x1="8.5" y1="6.5" x2="12" y2="10"/><line x1="5.5" y1="3.5" x2="9" y2="7"/></svg>;
        const IconLayers = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>;
        const IconZoomIn = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>;
        const IconZoomOut = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg>;
        const IconFrame = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg>;
        const IconCrop = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 2v14a2 2 0 0 0 2 2h14"/><path d="M18 22V8a2 2 0 0 0-2-2H2"/><path d="M2 2l20 20" opacity="0"/></svg>;
        const IconPortrait = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="3" width="12" height="18" rx="2" fill="none"/></svg>;
        const IconLandscape = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="6" width="18" height="12" rx="2" fill="none"/></svg>;
        const IconHelp = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>;
        const IconRotate = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg>;
        const IconSquare = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>;
        const IconCircle = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/></svg>;
        const IconRefresh = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21.5 2v6h-6"/><path d="M21.34 15.57a10 10 0 1 1-.57-8.38"/></svg>;
        const IconDuplicate = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>;
        const IconUndo = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>;
        const IconRedo = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 3.7"/></svg>;

        // --- CONSTANTES ---
        const MARGIN_MM = 5;
        const MARGIN_IN = MARGIN_MM / 25.4;
        const BASE_PPI = 96;
        const SNAP_THRESHOLD_PX = 10;

        // --- COMPONENTE PRINCIPAL ---
        function App() {
            // -- Estados Principales --
            const [pages, setPages] = useState([{ id: 1, width: 8.5, height: 11, name: 'Carta' }]);
            const [activePageId, setActivePageId] = useState(1);
            const [customSize, setCustomSize] = useState({ width: 24, height: 36 });
            const [isCustom, setIsCustom] = useState(false);
            const [unit, setUnit] = useState('cm'); 
            const [zoom, setZoom] = useState(0.5);
            const [images, setImages] = useState([]);
            const [selectedIds, setSelectedIds] = useState([]);
            const [showHelp, setShowHelp] = useState(false);
            
            // Clipboard & History
            const [internalClipboard, setInternalClipboard] = useState([]);
            const [history, setHistory] = useState([]); // Array de estados
            const [historyIndex, setHistoryIndex] = useState(-1); // Puntero al estado actual

            // -- Estados de Interacción --
            const [isDragging, setIsDragging] = useState(false);
            const [isPanning, setIsPanning] = useState(false);
            const [dragState, setDragState] = useState(null); // type: 'MOVE', 'PAN', 'RESIZE'
            const [guides, setGuides] = useState([]); 
            const scrollContainerRef = useRef(null);

            // -- Estados de Recorte --
            const [cropTarget, setCropTarget] = useState(null);
            const [cropRect, setCropRect] = useState(null);
            const [cropDragMode, setCropDragMode] = useState('none'); 
            const [cropDragOffset, setCropDragOffset] = useState({ x: 0, y: 0 });
            const [cropCursor, setCropCursor] = useState('crosshair');
            const [mouseStart, setMouseStart] = useState(null);
            const [cropShape, setCropShape] = useState('rect'); 
            const cropCanvasRef = useRef(null);
            const cropImageRef = useRef(null);

            // Visualización PPI
            const CURRENT_PPI = BASE_PPI * zoom; 
            const activePage = pages.find(p => p.id === activePageId) || pages[0];

            // Helpers Conversión
            const toDisplay = (valInches) => valInches === undefined ? '' : parseFloat((unit === 'cm' ? valInches * 2.54 : valInches).toFixed(2));
            const fromDisplay = (valDisplay) => { const num = parseFloat(valDisplay); return isNaN(num) ? 0 : (unit === 'cm' ? num / 2.54 : num); };
            const pxToIn = (px) => parseInt(px) / 96;
            const inToPx = (inc) => Math.round(inc * 96);

            // --- Lógica de Historial (Undo/Redo) ---
            // Guardar estado actual antes de un cambio
            const pushHistory = () => {
                const currentImagesState = JSON.parse(JSON.stringify(images));
                const newHistory = history.slice(0, historyIndex + 1); // Cortar futuro si existe
                newHistory.push(currentImagesState);
                
                // Limitar tamaño del historial
                if (newHistory.length > 30) newHistory.shift();
                
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
            };

            // Solo al iniciar, guardar estado vacío
            useEffect(() => {
                if (historyIndex === -1 && images.length === 0) {
                    setHistory([[]]);
                    setHistoryIndex(0);
                }
            }, []);

            const undo = () => {
                if (historyIndex > 0) {
                    const newIndex = historyIndex - 1;
                    setImages(history[newIndex]);
                    setHistoryIndex(newIndex);
                    setSelectedIds([]);
                }
            };

            const redo = () => {
                if (historyIndex < history.length - 1) {
                    const newIndex = historyIndex + 1;
                    setImages(history[newIndex]);
                    setHistoryIndex(newIndex);
                    setSelectedIds([]);
                }
            };

            // --- Lógica de Páginas y Layout ---
            const addPage = () => {
                const newId = Math.max(...pages.map(p => p.id)) + 1;
                setPages([...pages, { ...activePage, id: newId }]);
                setActivePageId(newId);
            };
            const removePage = (id) => {
                if (pages.length <= 1) return; 
                const newPages = pages.filter(p => p.id !== id);
                setPages(newPages);
                if (activePageId === id) setActivePageId(newPages[newPages.length - 1].id);
                setImages(images.filter(img => img.pageId !== id));
            };
            const handlePaperChange = (e) => {
                const val = e.target.value;
                let newSize = { ...activePage };
                if (val === 'custom') { 
                    setIsCustom(true); newSize.width = customSize.width; newSize.height = customSize.height; newSize.name = 'Personalizado'; 
                } else { 
                    setIsCustom(false); 
                    const sizes = { 
                        'letter': {width:8.5,height:11, name: 'Carta'}, 
                        'legal': {width:8.5,height:14, name: 'Oficio'}, 
                        'double_letter': {width:11,height:17, name: 'Doble Carta'}, 
                        'tabloid1218': {width:12,height:18, name: 'Tabloide 12x18'}, 
                        'tabloid1319': {width:13,height:19, name: 'Tabloide 13x19'}, 
                        'plotter': {width:24,height:36, name: 'Plotter'} 
                    }; 
                    newSize = { ...newSize, ...sizes[val] }; 
                }
                setPages(pages.map(p => p.id === activePageId ? newSize : p));
            };
            const toggleOrientation = (orient) => {
                const p = activePage;
                const isPortrait = p.height >= p.width;
                let newW = p.width; let newH = p.height;
                if (orient === 'portrait' && !isPortrait) { newW = p.height; newH = p.width; } 
                else if (orient === 'landscape' && isPortrait) { newW = p.height; newH = p.width; }
                setPages(pages.map(pg => pg.id === activePageId ? { ...pg, width: newW, height: newH } : pg));
            };
            const updateCustomDimension = (dim, displayVal) => {
                const inches = fromDisplay(displayVal);
                setCustomSize(prev => ({ ...prev, [dim]: inches }));
                setPages(pages.map(p => p.id === activePageId ? { ...p, [dim]: inches, name: 'Personalizado' } : p));
            };

            // --- Gestión de Imágenes ---
            const processImageFile = (file) => {
                pushHistory(); 
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const aspect = img.width / img.height;
                        const newImage = {
                            id: Date.now() + Math.random(),
                            pageId: activePageId, 
                            src: event.target.result,
                            originalSrc: event.target.result, 
                            width: 4, height: 4 / aspect,
                            x: MARGIN_IN + 0.5, y: MARGIN_IN + 0.5,
                            rotation: 0,
                            originalAspect: aspect,
                            borderSize: 0, borderColor: '#000000',
                            shape: 'rect' 
                        };
                        setImages(prev => [...prev, newImage]);
                        setSelectedIds([newImage.id]); 
                    };
                };
                reader.readAsDataURL(file);
            };
            const handleImageUpload = (e) => {
                const files = Array.from(e.target.files);
                files.forEach(processImageFile);
                e.target.value = '';
            };
            useEffect(() => {
                const handlePaste = (e) => {
                    const items = e.clipboardData?.items;
                    if (!items) return;
                    for (let i = 0; i < items.length; i++) {
                        if (items[i].type.indexOf('image') !== -1) { processImageFile(items[i].getAsFile()); }
                    }
                };
                document.addEventListener('paste', handlePaste);
                return () => document.removeEventListener('paste', handlePaste);
            }, [activePageId, images, historyIndex]); 

            const updateSelectedImages = (field, value) => {
                // Para updates continuos desde input, no hacemos pushHistory en cada letra, 
                // idealmente onBlur, pero simplificamos aqui sin history continuo
                if (selectedIds.length === 0) return;
                let finalVal = value;
                if (['width','height','x','y'].includes(field)) finalVal = fromDisplay(value);
                if (field === 'borderSizePx') { finalVal = pxToIn(value); field = 'borderSize'; }
                if (field === 'rotation') finalVal = parseFloat(value) % 360; 
                setImages(images.map(img => selectedIds.includes(img.id) ? { ...img, [field]: finalVal } : img));
            };
            const rotateSelected = (angle) => {
                pushHistory();
                setImages(images.map(img => selectedIds.includes(img.id) ? { ...img, rotation: (img.rotation + angle) % 360 } : img));
            };
            const fixAspectRatio = () => {
                pushHistory();
                setImages(images.map(img => selectedIds.includes(img.id) ? { ...img, height: img.width / img.originalAspect } : img));
            };
            const deleteSelected = () => {
                pushHistory();
                setImages(images.filter(img => !selectedIds.includes(img.id)));
                setSelectedIds([]);
            };

            const copySelection = () => {
                const selected = images.filter(img => selectedIds.includes(img.id));
                if (selected.length > 0) {
                    setInternalClipboard(selected);
                }
            };

            const pasteInternal = () => {
                if (internalClipboard.length === 0) return;
                pushHistory();
                const newImages = internalClipboard.map(img => ({
                    ...img,
                    id: Date.now() + Math.random(),
                    pageId: activePageId, 
                    x: img.x + 0.2, 
                    y: img.y + 0.2
                }));
                setImages(prev => [...prev, ...newImages]);
                setSelectedIds(newImages.map(img => img.id));
            };

            const duplicateSelected = () => {
                const selected = images.filter(img => selectedIds.includes(img.id));
                if (selected.length === 0) return;
                pushHistory();
                const newImages = selected.map(img => ({
                    ...img,
                    id: Date.now() + Math.random(),
                    x: img.x + 0.2,
                    y: img.y + 0.2
                }));
                setImages(prev => [...prev, ...newImages]);
                setSelectedIds(newImages.map(img => img.id));
            };

            // --- Atajos de Teclado ---
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

                    if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
                    if ((e.ctrlKey || e.metaKey) && e.key === 'c') copySelection();
                    if ((e.ctrlKey || e.metaKey) && e.key === 'v') pasteInternal();
                    if ((e.ctrlKey || e.metaKey) && e.key === 'd') { e.preventDefault(); duplicateSelected(); }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [selectedIds, images, internalClipboard, history, historyIndex]);

            // --- CROP ---
            const initiateCrop = () => {
                if (selectedIds.length !== 1) { alert("Selecciona una sola imagen para recortar."); return; }
                const img = images.find(i => i.id === selectedIds[0]);
                setCropTarget(img); setCropRect(null); setCropShape('rect'); 
                setCropDragMode('none');
            };
            const closeCrop = () => { setCropTarget(null); setCropRect(null); };

            const handleCropCanvasMouseDownWrapper = (e) => {
                const rect = cropCanvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                let clickedInside = false;
                if (cropRect && cropRect.w > 0 && cropRect.h > 0) {
                    if (cropShape === 'rect') {
                        if (x >= cropRect.x && x <= cropRect.x + cropRect.w && y >= cropRect.y && y <= cropRect.y + cropRect.h) clickedInside = true;
                    } else {
                        const cx = cropRect.x + cropRect.w / 2; const cy = cropRect.y + cropRect.h / 2; const radius = cropRect.w / 2;
                        if (Math.hypot(x - cx, y - cy) <= radius) clickedInside = true;
                    }
                }
                if (clickedInside) { setCropDragMode('move'); setCropDragOffset({ x: x - cropRect.x, y: y - cropRect.y }); } 
                else { setCropDragMode('create'); setMouseStart({ x, y }); setCropRect({ x, y, w: 0, h: 0 }); }
            };

            const handleCropCanvasMouseMoveWrapper = (e) => {
                const rect = cropCanvasRef.current.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                const canvasW = cropCanvasRef.current.width;
                const canvasH = cropCanvasRef.current.height;

                if (cropDragMode === 'none') {
                    let isOver = false;
                    if (cropRect && cropRect.w > 0) {
                        if (cropShape === 'rect') {
                            if (currentX >= cropRect.x && currentX <= cropRect.x + cropRect.w && currentY >= cropRect.y && currentY <= cropRect.y + cropRect.h) isOver = true;
                        } else {
                            const cx = cropRect.x + cropRect.w / 2; const cy = cropRect.y + cropRect.h / 2;
                            if (Math.hypot(currentX - cx, currentY - cy) <= cropRect.w / 2) isOver = true;
                        }
                    }
                    setCropCursor(isOver ? 'move' : 'crosshair');
                    return;
                }

                if (cropDragMode === 'create' && mouseStart) {
                    let w = Math.abs(currentX - mouseStart.x);
                    let h = Math.abs(currentY - mouseStart.y);
                    if (cropShape === 'circle') { const size = Math.max(w, h); w = size; h = size; }
                    const newX = currentX < mouseStart.x ? mouseStart.x - w : mouseStart.x;
                    const newY = currentY < mouseStart.y ? mouseStart.y - h : mouseStart.y;
                    setCropRect({ x: newX, y: newY, w, h });
                } else if (cropDragMode === 'move' && cropRect) {
                    let newX = currentX - cropDragOffset.x;
                    let newY = currentY - cropDragOffset.y;
                    newX = Math.max(0, Math.min(newX, canvasW - cropRect.w));
                    newY = Math.max(0, Math.min(newY, canvasH - cropRect.h));
                    setCropRect(prev => ({ ...prev, x: newX, y: newY }));
                }
            };

            const handleCropCanvasMouseUp = () => { setCropDragMode('none'); setMouseStart(null); };
            
            const applyCrop = () => {
                if (!cropRect || cropRect.w === 0 || cropRect.h === 0) { closeCrop(); return; }
                pushHistory(); 
                const canvas = cropCanvasRef.current, imgElement = cropImageRef.current; 
                const scaleX = imgElement.naturalWidth / canvas.width, scaleY = imgElement.naturalHeight / canvas.height;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = cropRect.w * scaleX; tempCanvas.height = cropRect.h * scaleY;
                const ctx = tempCanvas.getContext('2d');
                if (cropShape === 'circle') {
                    ctx.beginPath(); ctx.ellipse(tempCanvas.width/2, tempCanvas.height/2, tempCanvas.width/2, tempCanvas.height/2, 0, 0, 2*Math.PI); ctx.clip();
                }
                ctx.drawImage(imgElement, cropRect.x * scaleX, cropRect.y * scaleY, cropRect.w * scaleX, cropRect.h * scaleY, 0, 0, tempCanvas.width, tempCanvas.height);
                const newSrc = tempCanvas.toDataURL('image/png');
                setImages(images.map(img => {
                    if (img.id === cropTarget.id) {
                        const newAspect = tempCanvas.width / tempCanvas.height;
                        return { ...img, src: newSrc, height: img.width / newAspect, originalAspect: newAspect, shape: cropShape };
                    } return img;
                }));
                closeCrop();
            };

            useEffect(() => {
                if (cropTarget && cropCanvasRef.current) {
                    const canvas = cropCanvasRef.current, ctx = canvas.getContext('2d'), img = cropImageRef.current;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if(img.complete) ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                    if (cropRect) {
                        ctx.save();
                        if (cropShape === 'circle') {
                            ctx.beginPath(); ctx.ellipse(cropRect.x + cropRect.w/2, cropRect.y + cropRect.h/2, cropRect.w/2, cropRect.h/2, 0, 0, 2*Math.PI); ctx.clip();
                            ctx.clearRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);
                            ctx.drawImage(img, (cropRect.x/canvas.width)*img.naturalWidth, (cropRect.y/canvas.height)*img.naturalHeight, (cropRect.w/canvas.width)*img.naturalWidth, (cropRect.h/canvas.height)*img.naturalHeight, cropRect.x, cropRect.y, cropRect.w, cropRect.h);
                            ctx.restore();
                            ctx.beginPath(); ctx.ellipse(cropRect.x + cropRect.w/2, cropRect.y + cropRect.h/2, cropRect.w/2, cropRect.h/2, 0, 0, 2*Math.PI); ctx.strokeStyle = 'red'; ctx.lineWidth = 2; ctx.stroke();
                        } else {
                            ctx.clearRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);
                            ctx.drawImage(img, (cropRect.x/canvas.width)*img.naturalWidth, (cropRect.y/canvas.height)*img.naturalHeight, (cropRect.w/canvas.width)*img.naturalWidth, (cropRect.h/canvas.height)*img.naturalHeight, cropRect.x, cropRect.y, cropRect.w, cropRect.h);
                            ctx.strokeStyle = 'red'; ctx.lineWidth = 2; ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);
                        }
                    }
                }
            }, [cropRect, cropTarget, cropShape, cropDragMode]);

            // --- Scroll Zoom (Shift + Scroll) ---
            useEffect(() => {
                const container = scrollContainerRef.current;
                if (!container) return;

                const handleWheel = (e) => {
                    if (e.shiftKey) {
                        e.preventDefault();
                        const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
                        setZoom(prev => Math.min(3.0, Math.max(0.1, parseFloat((prev + zoomDelta).toFixed(1)))));
                    }
                };

                container.addEventListener('wheel', handleWheel, { passive: false });
                return () => container.removeEventListener('wheel', handleWheel);
            }, []);

            // --- Interacciones Main Canvas (Move & Resize) ---
            const handleMouseDown = (e, img, handleType = null) => {
                if (e.button === 1 || (!img && e.button === 0 && !handleType)) { 
                    if (e.button === 1) e.preventDefault(); 
                    setIsPanning(true);
                    if (scrollContainerRef.current) {
                        setDragState({ type: 'PAN', startX: e.clientX, startY: e.clientY, initialScrollLeft: scrollContainerRef.current.scrollLeft, initialScrollTop: scrollContainerRef.current.scrollTop });
                    }
                    return; 
                }
                
                // Resizing
                if (handleType && img) {
                    e.stopPropagation();
                    pushHistory();
                    setDragState({ 
                        type: 'RESIZE', 
                        imgId: img.id, 
                        handle: handleType,
                        startX: e.clientX, 
                        startY: e.clientY, 
                        startW: img.width, 
                        startH: img.height,
                        startImgX: img.x,
                        startImgY: img.y,
                        aspect: img.width / img.height
                    });
                    setIsDragging(true);
                    return;
                }

                if (img) { 
                    pushHistory(); 
                    e.stopPropagation();
                    let newSelection = [...selectedIds];
                    if (e.ctrlKey || e.metaKey) { newSelection.includes(img.id) ? newSelection = newSelection.filter(id=>id!==img.id) : newSelection.push(img.id); } 
                    else { if (!newSelection.includes(img.id)) newSelection = [img.id]; }
                    setSelectedIds(newSelection);
                    setIsDragging(true);
                    const initialPositions = {};
                    images.forEach(i => { if (newSelection.includes(i.id)) initialPositions[i.id] = { x: i.x, y: i.y }; });
                    setDragState({ type: 'MOVE', startX: e.clientX, startY: e.clientY, initialPositions });
                }
            };

            const getRotatedBounds = (x, y, w, h, rotationDeg) => {
                const rad = rotationDeg * (Math.PI / 180);
                const cos = Math.cos(rad); const sin = Math.sin(rad);
                const p0 = {x:0,y:0}, p1 = {x:w,y:0}, p2 = {x:w,y:h}, p3 = {x:0,y:h};
                const rotate = (p) => ({ x: p.x*cos - p.y*sin, y: p.x*sin + p.y*cos });
                const r0=rotate(p0), r1=rotate(p1), r2=rotate(p2), r3=rotate(p3);
                const minRx = Math.min(r0.x,r1.x,r2.x,r3.x), maxRx = Math.max(r0.x,r1.x,r2.x,r3.x);
                const minRy = Math.min(r0.y,r1.y,r2.y,r3.y), maxRy = Math.max(r0.y,r1.y,r2.y,r3.y);
                return { minRx, maxRx, minRy, maxRy };
            };

            const handleMouseMove = (e) => {
                if (isPanning && dragState?.type === 'PAN' && scrollContainerRef.current) {
                    e.preventDefault(); 
                    scrollContainerRef.current.scrollLeft = dragState.initialScrollLeft - (e.clientX - dragState.startX);
                    scrollContainerRef.current.scrollTop = dragState.initialScrollTop - (e.clientY - dragState.startY);
                    return;
                }
                
                if (!isDragging || !dragState) return;

                // RESIZE LOGIC
                if (dragState.type === 'RESIZE') {
                    e.preventDefault();
                    const deltaX = (e.clientX - dragState.startX) / CURRENT_PPI;
                    const deltaY = (e.clientY - dragState.startY) / CURRENT_PPI;
                    
                    let newW = dragState.startW;
                    let newH = dragState.startH;
                    let newX = dragState.startImgX;
                    let newY = dragState.startImgY;

                    // Calcular nuevo tamaño basado en qué esquina se arrastra
                    switch(dragState.handle) {
                        case 'se': 
                            newW = Math.max(0.1, dragState.startW + deltaX); 
                            newH = Math.max(0.1, dragState.startH + deltaY); 
                            break;
                        case 'sw': 
                            newW = Math.max(0.1, dragState.startW - deltaX); 
                            newH = Math.max(0.1, dragState.startH + deltaY); 
                            newX = dragState.startImgX + (dragState.startW - newW);
                            break;
                        case 'ne': 
                            newW = Math.max(0.1, dragState.startW + deltaX); 
                            newH = Math.max(0.1, dragState.startH - deltaY); 
                            newY = dragState.startImgY + (dragState.startH - newH);
                            break;
                        case 'nw': 
                            newW = Math.max(0.1, dragState.startW - deltaX); 
                            newH = Math.max(0.1, dragState.startH - deltaY); 
                            newX = dragState.startImgX + (dragState.startW - newW);
                            newY = dragState.startImgY + (dragState.startH - newH);
                            break;
                    }

                    // Proporcionalidad con Shift
                    if (e.shiftKey) {
                        // Usar el eje mayor de cambio para determinar el tamaño
                        if (newW / dragState.aspect > newH) {
                            newH = newW / dragState.aspect;
                        } else {
                            newW = newH * dragState.aspect;
                        }
                        // Reajustar posición si es resize desde izquierda o arriba
                        if (dragState.handle.includes('w')) newX = dragState.startImgX + (dragState.startW - newW);
                        if (dragState.handle.includes('n')) newY = dragState.startImgY + (dragState.startH - newH);
                    }

                    setImages(images.map(img => img.id === dragState.imgId ? { ...img, x: newX, y: newY, width: newW, height: newH } : img));
                    return;
                }

                if (dragState.type !== 'MOVE') return;

                let deltaX = (e.clientX - dragState.startX) / CURRENT_PPI;
                let deltaY = (e.clientY - dragState.startY) / CURRENT_PPI;
                const minX = MARGIN_IN, minY = MARGIN_IN, maxX = activePage.width - MARGIN_IN, maxY = activePage.height - MARGIN_IN;
                
                // SNAPPING
                const snapThreshIn = SNAP_THRESHOLD_PX / CURRENT_PPI;
                let snapAdjustmentX = 0, snapAdjustmentY = 0;
                let activeGuides = [];
                const targetImages = images.filter(img => !selectedIds.includes(img.id) && img.pageId === activePageId);
                const movingImagesProto = images.filter(img => selectedIds.includes(img.id)).map(img => {
                    const startPos = dragState.initialPositions[img.id];
                    return { ...img, x: startPos.x + deltaX, y: startPos.y + deltaY }; 
                });

                let snappedX = false, snappedY = false;
                const checkSnap = (val1, val2) => Math.abs(val1 - val2) < snapThreshIn;

                for (let mImg of movingImagesProto) {
                    if (snappedX && snappedY) break;
                    const mLeft = mImg.x; const mRight = mImg.x + mImg.width; const mCenterX = mImg.x + mImg.width / 2;
                    const mTop = mImg.y; const mBottom = mImg.y + mImg.height; const mCenterY = mImg.y + mImg.height / 2;

                    for (let tImg of targetImages) {
                        const tLeft = tImg.x; const tRight = tImg.x + tImg.width; const tCenterX = tImg.x + tImg.width / 2;
                        const tTop = tImg.y; const tBottom = tImg.y + tImg.height; const tCenterY = tImg.y + tImg.height / 2;

                        if (!snappedX) {
                            if (checkSnap(mLeft, tLeft)) { snapAdjustmentX = tLeft - mLeft; snappedX = true; activeGuides.push({ type: 'v', pos: tLeft }); }
                            else if (checkSnap(mLeft, tRight)) { snapAdjustmentX = tRight - mLeft; snappedX = true; activeGuides.push({ type: 'v', pos: tRight }); }
                            else if (checkSnap(mRight, tLeft)) { snapAdjustmentX = tLeft - mRight; snappedX = true; activeGuides.push({ type: 'v', pos: tLeft }); }
                            else if (checkSnap(mRight, tRight)) { snapAdjustmentX = tRight - mRight; snappedX = true; activeGuides.push({ type: 'v', pos: tRight }); }
                            else if (checkSnap(mCenterX, tCenterX)) { snapAdjustmentX = tCenterX - mCenterX; snappedX = true; activeGuides.push({ type: 'v', pos: tCenterX }); }
                        }
                        if (!snappedY) {
                            if (checkSnap(mTop, tTop)) { snapAdjustmentY = tTop - mTop; snappedY = true; activeGuides.push({ type: 'h', pos: tTop }); }
                            else if (checkSnap(mTop, tBottom)) { snapAdjustmentY = tBottom - mTop; snappedY = true; activeGuides.push({ type: 'h', pos: tBottom }); }
                            else if (checkSnap(mBottom, tTop)) { snapAdjustmentY = tTop - mBottom; snappedY = true; activeGuides.push({ type: 'h', pos: tTop }); }
                            else if (checkSnap(mBottom, tBottom)) { snapAdjustmentY = tBottom - mBottom; snappedY = true; activeGuides.push({ type: 'h', pos: tBottom }); }
                            else if (checkSnap(mCenterY, tCenterY)) { snapAdjustmentY = tCenterY - mCenterY; snappedY = true; activeGuides.push({ type: 'h', pos: tCenterY }); }
                        }
                    }
                }
                setGuides(activeGuides);

                let proposedDeltaX = deltaX + snapAdjustmentX;
                let proposedDeltaY = deltaY + snapAdjustmentY;

                // RESTRICCIÓN DE MÁRGENES
                let minDx = -Infinity, maxDx = Infinity, minDy = -Infinity, maxDy = Infinity;
                selectedIds.forEach(id => {
                    const pos = dragState.initialPositions[id];
                    const img = images.find(i => i.id === id);
                    if (!pos || !img) return;
                    const bounds = getRotatedBounds(pos.x, pos.y, img.width, img.height, img.rotation || 0);
                    const spaceLeft = (pos.x + bounds.minRx) - minX;
                    const spaceRight = maxX - (pos.x + bounds.maxRx);
                    const spaceTop = (pos.y + bounds.minRy) - minY;
                    const spaceBottom = maxY - (pos.y + bounds.maxRy);
                    minDx = Math.max(minDx, -spaceLeft); maxDx = Math.min(maxDx, spaceRight);
                    minDy = Math.max(minDy, -spaceTop); maxDy = Math.min(maxDy, spaceBottom);
                });
                const finalDeltaX = Math.max(minDx, Math.min(proposedDeltaX, maxDx));
                const finalDeltaY = Math.max(minDy, Math.min(proposedDeltaY, maxDy));

                setImages(images.map(img => selectedIds.includes(img.id) ? { ...img, x: dragState.initialPositions[img.id].x + finalDeltaX, y: dragState.initialPositions[img.id].y + finalDeltaY } : img));
            };

            const handleMouseUp = (e) => {
                if (dragState?.type === 'PAN' && Math.hypot(e.clientX - dragState.startX, e.clientY - dragState.startY) < 5) setSelectedIds([]);
                setIsDragging(false); setIsPanning(false); setDragState(null); setGuides([]);
            };

            const generatePDF = () => {
                if (!window.jspdf) return;
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: pages[0].width > pages[0].height ? 'l' : 'p', unit: 'in', format: [pages[0].width, pages[0].height] });
                pages.forEach((page, index) => {
                    if (index > 0) doc.addPage([page.width, page.height], page.width > page.height ? 'l' : 'p');
                    images.filter(i => i.pageId === page.id).forEach(img => {
                        try {
                            const rot = img.rotation || 0;
                            if (img.borderSize > 0) {
                                const r = parseInt(img.borderColor.slice(1, 3), 16), g = parseInt(img.borderColor.slice(3, 5), 16), b = parseInt(img.borderColor.slice(5, 7), 16);
                                doc.setFillColor(r, g, b);
                                if (img.shape === 'circle') {
                                    const radius = (img.width / 2) + img.borderSize;
                                    const cx = img.x + (img.width / 2);
                                    const cy = img.y + (img.height / 2);
                                    doc.circle(cx, cy, radius, 'F');
                                } else {
                                    if(rot === 0) doc.rect(img.x - img.borderSize, img.y - img.borderSize, img.width + img.borderSize*2, img.height + img.borderSize*2, 'F');
                                }
                            }
                            doc.addImage(img.src, 'JPEG', img.x, img.y, img.width, img.height, undefined, 'FAST', rot);
                        } catch (e) {}
                    });
                });
                doc.save(`Impresion_${Date.now()}.pdf`);
            };

            const currentImages = images.filter(img => img.pageId === activePageId);
            const firstSelected = images.find(i => i.id === selectedIds[0]);

            return (
                <div className="flex flex-col h-screen text-gray-800 font-sans" onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onContextMenu={(e)=>e.preventDefault()}>
                    <header className="bg-slate-800 text-white p-3 shadow-md flex justify-between items-center z-[60] relative shrink-0">
                        <div className="flex items-center gap-2"><div className="text-blue-400"><IconSettings /></div><div><h1 className="text-lg font-bold leading-tight">Optimizador de Impresión</h1></div></div>
                        <div className="flex flex-col items-end gap-1">
                            <button onClick={generatePDF} className="bg-green-600 hover:bg-green-500 text-white px-4 py-2 rounded-lg font-bold flex items-center gap-2 shadow-lg transition-all text-sm"><IconFileDown /> Descargar PDF</button>
                            <button onClick={()=>setShowHelp(true)} className="text-[10px] text-blue-200 hover:text-white flex items-center gap-1 hover:underline"><IconHelp /> ¿Cómo usar?</button>
                        </div>
                    </header>

                    <div className="flex flex-1 overflow-hidden relative">
                        <div className="w-80 bg-white shadow-xl z-20 flex flex-col border-r border-gray-200 overflow-y-auto shrink-0">
                            {/* Panel Izquierdo (Controles) */}
                            <div className="p-4 bg-gray-50 border-b flex justify-between items-center"><span className="text-xs font-bold text-gray-500 uppercase flex items-center gap-1"><IconRuler /> Unidades:</span><div className="flex items-center bg-white border border-gray-300 rounded-lg overflow-hidden text-xs font-bold"><button onClick={()=>setUnit('cm')} className={`px-3 py-1.5 ${unit==='cm'?'bg-blue-600 text-white':'text-gray-600'}`}>CM</button><button onClick={()=>setUnit('in')} className={`px-3 py-1.5 ${unit==='in'?'bg-blue-600 text-white':'text-gray-600'}`}>IN</button></div></div>
                            <div className="p-5 border-b bg-blue-50/30">
                                <h2 className="text-xs font-bold text-blue-800 uppercase tracking-wide mb-2 flex justify-between"><span>Hoja Actual</span><span className="text-blue-500">{toDisplay(activePage.width)}x{toDisplay(activePage.height)} {unit}</span></h2>
                                <select onChange={handlePaperChange} className="w-full p-2 border border-blue-200 rounded text-sm mb-2">
                                    <option value="letter">Carta (Letter)</option>
                                    <option value="legal">Oficio (Legal)</option>
                                    <option value="double_letter">Doble Carta</option>
                                    <option value="tabloid1218">Tabloide 12x18</option>
                                    <option value="tabloid1319">Tabloide 13x19</option>
                                    <option value="plotter">Plotter</option>
                                    <option value="custom">Personalizado...</option>
                                </select>
                                <div className="flex gap-2 mb-2">
                                    <button onClick={() => toggleOrientation('portrait')} className={`flex-1 flex items-center justify-center p-2 rounded border ${activePage.height >= activePage.width ? 'bg-blue-100 border-blue-400 text-blue-700' : 'bg-white border-gray-300'}`} title="Vertical"><IconPortrait /></button>
                                    <button onClick={() => toggleOrientation('landscape')} className={`flex-1 flex items-center justify-center p-2 rounded border ${activePage.width > activePage.height ? 'bg-blue-100 border-blue-400 text-blue-700' : 'bg-white border-gray-300'}`} title="Horizontal"><IconLandscape /></button>
                                </div>
                                <div className="grid grid-cols-2 gap-2"><div><label className="text-[10px] font-bold">ANCHO</label><input type="number" step="0.1" value={toDisplay(activePage.width)} onChange={e=>updateCustomDimension('width',e.target.value)} className="w-full p-1.5 border rounded text-sm"/></div><div><label className="text-[10px] font-bold">ALTO</label><input type="number" step="0.1" value={toDisplay(activePage.height)} onChange={e=>updateCustomDimension('height',e.target.value)} className="w-full p-1.5 border rounded text-sm"/></div></div>
                            </div>
                            <div className="p-5 border-b"><label className="flex flex-col items-center justify-center w-full h-20 border-2 border-dashed border-gray-300 rounded-lg cursor-pointer hover:bg-gray-50"><div className="text-gray-400"><IconUpload /></div><p className="text-xs text-gray-500 mt-1">Subir o Pegar (Ctrl+V)</p><input type="file" multiple accept="image/*" className="hidden" onChange={handleImageUpload} /></label></div>
                            
                            <div className="p-5 flex-1 bg-gray-50">
                                {firstSelected ? (
                                    <div className="space-y-4">
                                        <div className="bg-white p-3 rounded shadow-sm border border-gray-200">
                                            <div className="flex justify-between items-center mb-2"><span className="text-xs font-semibold text-blue-600 bg-blue-50 px-2 py-0.5 rounded">Editando</span><button onClick={deleteSelected} className="text-gray-400 hover:text-red-500"><IconTrash /></button></div>
                                            
                                            {/* Dimensiones */}
                                            <div className="grid grid-cols-2 gap-3 mb-3">
                                                <div><label className="block text-[10px] font-bold mb-1">ANCHO</label><input type="number" step="0.1" value={toDisplay(firstSelected.width)} onChange={e=>updateSelectedImages('width',e.target.value)} className="w-full p-2 border border-blue-200 rounded text-sm"/></div>
                                                <div><label className="block text-[10px] font-bold mb-1">ALTO</label><input type="number" step="0.1" value={toDisplay(firstSelected.height)} onChange={e=>updateSelectedImages('height',e.target.value)} className="w-full p-2 border border-blue-200 rounded text-sm"/></div>
                                            </div>

                                            {/* ROTACIÓN */}
                                            <div className="mb-3 pt-2 border-t border-gray-100">
                                                <div className="flex justify-between items-center mb-1">
                                                    <label className="text-[10px] font-bold flex items-center gap-1"><IconRotate /> ROTACIÓN</label>
                                                    <span className="text-xs text-blue-600 font-mono">{Math.round(firstSelected.rotation || 0)}°</span>
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <button onClick={()=>rotateSelected(-90)} className="p-1 bg-gray-100 hover:bg-gray-200 rounded text-[10px] font-bold">-90°</button>
                                                    <input type="range" min="0" max="360" value={firstSelected.rotation || 0} onChange={e=>updateSelectedImages('rotation',e.target.value)} className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                    <button onClick={()=>rotateSelected(90)} className="p-1 bg-gray-100 hover:bg-gray-200 rounded text-[10px] font-bold">+90°</button>
                                                </div>
                                            </div>
                                            
                                            {/* BOTÓN RECORTAR */}
                                            {selectedIds.length === 1 && (
                                                <button onClick={initiateCrop} className="w-full mb-3 bg-gray-100 hover:bg-gray-200 text-gray-700 py-2 px-3 rounded text-sm font-bold flex items-center justify-center gap-2 border border-gray-300 transition-all">
                                                    <IconCrop /> <span className="text-xs">RECORTAR IMAGEN</span>
                                                </button>
                                            )}

                                            <div className="mb-4 pt-3 border-t border-gray-100">
                                                <div className="flex justify-between mb-2"><span className="text-xs font-bold flex items-center gap-1"><IconFrame /> Borde (Px)</span><input type="color" value={firstSelected.borderColor} onChange={e=>updateSelectedImages('borderColor',e.target.value)} className="w-6 h-6 border-none p-0 rounded overflow-hidden cursor-pointer"/></div>
                                                <select value={inToPx(firstSelected.borderSize)} onChange={e=>updateSelectedImages('borderSizePx',e.target.value)} className="w-full p-2 border border-gray-300 rounded text-sm"><option value="0">Sin borde</option><option value="1">1 px</option><option value="2">2 px</option><option value="3">3 px</option><option value="5">5 px</option><option value="10">10 px</option></select>
                                            </div>
                                            <button onClick={fixAspectRatio} className="w-full bg-white border border-gray-300 hover:bg-gray-50 text-gray-700 py-1.5 px-2 rounded text-xs flex items-center justify-center gap-1 font-medium mb-3"><IconCheck /> Igualar Proporción</button>
                                            
                                            <div className="flex gap-2">
                                                <button onClick={duplicateSelected} className="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 py-2 px-3 rounded text-sm font-bold flex items-center justify-center gap-2 shadow-sm border border-gray-300"><IconDuplicate /> Duplicar</button>
                                                <button onClick={()=>setSelectedIds([])} className="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-3 rounded text-sm font-bold flex items-center justify-center gap-2 shadow-sm">Aceptar</button>
                                            </div>
                                        </div>
                                    </div>
                                ) : <div className="text-center py-10 text-gray-400 text-sm border-2 border-dashed border-gray-200 rounded-lg">Selecciona una imagen.</div>}
                            </div>
                        </div>

                        {/* Area Canvas */}
                        <div className="flex-1 flex flex-col min-w-0 bg-gray-200 relative">
                            <div ref={scrollContainerRef} className="flex-1 overflow-auto relative" style={{ cursor: isPanning ? 'grabbing' : 'default' }} onMouseDown={e=>handleMouseDown(e, null)}>
                                <div className="min-w-full min-h-full flex items-center justify-center p-16 w-fit h-fit">
                                    <div className="bg-white shadow-2xl relative grid-bg flex-none transition-all duration-300" onClick={e=>e.stopPropagation()} style={{ width: `${activePage.width * CURRENT_PPI}px`, height: `${activePage.height * CURRENT_PPI}px`, backgroundSize: `${CURRENT_PPI}px ${CURRENT_PPI}px` }}>
                                        {/* Guías y Borde Seguro */}
                                        <div className="absolute border border-dashed border-red-300 pointer-events-none" style={{ top: `${MARGIN_IN*CURRENT_PPI}px`, left: `${MARGIN_IN*CURRENT_PPI}px`, right: `${MARGIN_IN*CURRENT_PPI}px`, bottom: `${MARGIN_IN*CURRENT_PPI}px` }}></div>
                                        
                                        {/* GUIAS MAGNÉTICAS */}
                                        {guides.map((g, i) => (
                                            <div key={i} className="absolute bg-fuchsia-500 z-[100] pointer-events-none shadow-[0_0_4px_rgba(255,0,255,0.8)]" 
                                                style={{ left: g.type==='v'?`${g.pos*CURRENT_PPI}px`:0, top: g.type==='h'?`${g.pos*CURRENT_PPI}px`:0, width: g.type==='v'?'1px':'100%', height: g.type==='h'?'1px':'100%' }} 
                                            />
                                        ))}

                                        {/* Imágenes */}
                                        {currentImages.map(img => (
                                            <div key={img.id} onMouseDown={e=>handleMouseDown(e, img)} onClick={e=>e.stopPropagation()} className={`absolute cursor-move group ${selectedIds.includes(img.id)?'z-50':'z-10'}`} 
                                                style={{ 
                                                    left: `${img.x * CURRENT_PPI}px`, top: `${img.y * CURRENT_PPI}px`, width: `${img.width * CURRENT_PPI}px`, height: `${img.height * CURRENT_PPI}px`,
                                                    borderWidth: `${img.borderSize * CURRENT_PPI}px`, borderStyle: 'solid', borderColor: img.borderColor, boxSizing: 'content-box',
                                                    transform: `rotate(${img.rotation || 0}deg)`, transformOrigin: 'top left',
                                                    borderRadius: img.shape === 'circle' ? '50%' : '0' 
                                                }}>
                                                <img src={img.src} className="w-full h-full object-fill pointer-events-none block" style={{ opacity: isDragging && selectedIds.includes(img.id) ? 0.7 : 1 }} />
                                                {selectedIds.includes(img.id) && (
                                                    <>
                                                        <div className="absolute inset-0 border-2 border-blue-600 pointer-events-none" style={{ margin: `-${img.borderSize * CURRENT_PPI + 2}px`, borderRadius: img.shape === 'circle' ? '50%' : '0' }}></div>
                                                        {/* Resize Handles */}
                                                        <div className="resize-handle resize-nw" onMouseDown={e=>handleMouseDown(e, img, 'nw')}></div>
                                                        <div className="resize-handle resize-ne" onMouseDown={e=>handleMouseDown(e, img, 'ne')}></div>
                                                        <div className="resize-handle resize-sw" onMouseDown={e=>handleMouseDown(e, img, 'sw')}></div>
                                                        <div className="resize-handle resize-se" onMouseDown={e=>handleMouseDown(e, img, 'se')}></div>
                                                    </>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                            
                            {/* Zoom y Paginación (Fijos z-60) */}
                            <div className="absolute bottom-20 right-8 bg-white p-2 rounded-lg shadow-xl border border-gray-200 flex items-center gap-3 z-[60]">
                                <button onClick={()=>setZoom(z=>Math.max(0.1,z-0.1))}><IconZoomOut /></button>
                                <select 
                                    className="bg-transparent text-xs font-bold text-center w-16 border-none outline-none cursor-pointer appearance-none hover:text-blue-600"
                                    value={zoom}
                                    onChange={(e) => setZoom(parseFloat(e.target.value))}
                                >
                                    <option value="0.25">25%</option>
                                    <option value="0.5">50%</option>
                                    <option value="0.75">75%</option>
                                    <option value="1">100%</option>
                                    <option value="1.25">125%</option>
                                    <option value="1.5">150%</option>
                                    <option value="2">200%</option>
                                </select>
                                <button onClick={()=>setZoom(z=>Math.min(3.0,z+0.1))}><IconZoomIn /></button>
                            </div>

                            {/* Floating Toolbar: Undo/Redo */}
                            <div className="absolute bottom-24 left-1/2 -translate-x-1/2 bg-white p-2 rounded-full shadow-xl border border-gray-200 flex items-center gap-2 z-[60]">
                                <button onClick={undo} className="p-2 hover:bg-gray-100 rounded-full text-gray-600" title="Deshacer (Ctrl+Z)" disabled={historyIndex <= 0} style={{opacity: historyIndex <= 0 ? 0.3 : 1}}>
                                    <IconUndo />
                                </button>
                                <div className="w-[1px] h-4 bg-gray-300"></div>
                                <button onClick={redo} className="p-2 hover:bg-gray-100 rounded-full text-gray-600" title="Rehacer (Ctrl+Y)" disabled={historyIndex >= history.length - 1} style={{opacity: historyIndex >= history.length - 1 ? 0.3 : 1}}>
                                    <IconRedo />
                                </button>
                            </div>

                            <div className="h-16 bg-white border-t border-gray-200 flex items-center px-4 gap-3 overflow-x-auto scrollbar-hide shrink-0 z-[60] relative shadow-lg">
                                <span className="text-xs font-bold text-gray-400 uppercase mr-2 sticky left-0 bg-white z-10 py-2">Hojas:</span>
                                {pages.map((p,idx) => (
                                    <div key={p.id} onClick={()=>setActivePageId(p.id)} className={`flex items-center gap-2 px-3 py-1.5 rounded-full border cursor-pointer min-w-[100px] ${activePageId===p.id?'border-blue-500 bg-blue-50 text-blue-700':'border-gray-200'}`}>
                                        <div className="flex flex-col"><span className="text-xs font-bold">Pág {idx+1}</span><span className="text-[9px] opacity-70">{toDisplay(p.width)}x{toDisplay(p.height)} {unit}</span></div>
                                        {pages.length>1 && <button onClick={e=>{e.stopPropagation();removePage(p.id)}} className="w-5 h-5 rounded-full hover:bg-red-100 text-gray-400 hover:text-red-500">×</button>}
                                    </div>
                                ))}
                                <button onClick={addPage} className="flex items-center gap-1 px-3 py-1.5 rounded-full border border-dashed border-gray-300 hover:border-blue-400 hover:text-blue-500 text-gray-400 text-xs font-bold"><IconPlus /> Nueva</button>
                            </div>
                        </div>
                    </div>

                    {/* --- MODAL DE RECORTE --- */}
                    {cropTarget && (
                        <div className="fixed inset-0 bg-black/90 z-[100] flex flex-col items-center justify-center p-4">
                            <div className="bg-white p-2 rounded-t-lg flex justify-between items-center w-full max-w-4xl">
                                <h3 className="font-bold text-gray-700 flex items-center gap-2"><IconCrop /> Recortar Imagen</h3>
                                <div className="flex items-center gap-2">
                                    <button 
                                        onClick={() => setCropRect(null)}
                                        className="p-2 rounded hover:bg-gray-100 text-gray-500"
                                        title="Reiniciar Corte"
                                    >
                                        <IconRefresh />
                                    </button>
                                    <div className="w-[1px] h-6 bg-gray-300 mx-1"></div>
                                    <button 
                                        onClick={() => setCropShape('rect')}
                                        className={`p-2 rounded hover:bg-gray-100 ${cropShape === 'rect' ? 'bg-blue-100 text-blue-600' : 'text-gray-500'}`}
                                        title="Rectángulo"
                                    >
                                        <IconSquare />
                                    </button>
                                    <button 
                                        onClick={() => setCropShape('circle')}
                                        className={`p-2 rounded hover:bg-gray-100 ${cropShape === 'circle' ? 'bg-blue-100 text-blue-600' : 'text-gray-500'}`}
                                        title="Círculo (Simétrico)"
                                    >
                                        <IconCircle />
                                    </button>
                                </div>
                            </div>
                            
                            <div className="relative bg-gray-800 w-full max-w-4xl h-[70vh] flex items-center justify-center overflow-hidden border-x border-gray-600 select-none">
                                <img 
                                    ref={cropImageRef} 
                                    src={cropTarget.originalSrc || cropTarget.src} 
                                    className="hidden" 
                                    onLoad={() => {
                                        const canvas = cropCanvasRef.current;
                                        const img = cropImageRef.current;
                                        if(canvas && img) {
                                            const aspect = img.naturalWidth / img.naturalHeight;
                                            const containerH = window.innerHeight * 0.7;
                                            const containerW = Math.min(window.innerWidth * 0.8, 1024);
                                            let drawW = containerW;
                                            let drawH = drawW / aspect;
                                            if (drawH > containerH) { drawH = containerH; drawW = drawH * aspect; }
                                            canvas.width = drawW; canvas.height = drawH;
                                            const ctx = canvas.getContext('2d');
                                            ctx.drawImage(img, 0, 0, drawW, drawH);
                                            ctx.fillStyle = 'rgba(0,0,0,0.5)';
                                            ctx.fillRect(0, 0, drawW, drawH);
                                        }
                                    }}
                                />
                                <canvas 
                                    ref={cropCanvasRef}
                                    style={{ cursor: cropCursor }}
                                    className="shadow-2xl"
                                    onMouseDown={handleCropCanvasMouseDownWrapper}
                                    onMouseMove={handleCropCanvasMouseMoveWrapper}
                                    onMouseUp={handleCropCanvasMouseUp}
                                    onMouseLeave={handleCropCanvasMouseUp}
                                />
                            </div>

                            <div className="bg-white p-4 rounded-b-lg w-full max-w-4xl flex justify-end gap-3">
                                <button onClick={closeCrop} className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded font-bold">Cancelar</button>
                                <button onClick={applyCrop} className="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded font-bold shadow-lg">Aplicar Recorte</button>
                            </div>
                        </div>
                    )}

                    {/* --- MODAL DE AYUDA --- */}
                    {showHelp && (
                        <div className="fixed inset-0 bg-black/60 z-[100] flex items-center justify-center p-4 animate-in fade-in duration-200">
                            <div className="bg-white rounded-xl shadow-2xl max-w-md w-full overflow-hidden">
                                <div className="bg-blue-600 text-white p-4 flex justify-between items-center">
                                    <h3 className="font-bold flex items-center gap-2"><IconHelp /> Guía Rápida</h3>
                                    <button onClick={()=>setShowHelp(false)} className="hover:bg-blue-700 rounded-full p-1">✕</button>
                                </div>
                                <div className="p-6 space-y-4 text-sm text-gray-700">
                                    <div className="flex gap-3">
                                        <div className="bg-blue-100 p-2 rounded h-fit text-blue-600"><IconMove /></div>
                                        <div><h4 className="font-bold">Mover Lienzo</h4><p>Mantén presionado la <b>rueda del mouse</b> (click central) o usa las barras de desplazamiento para moverte.</p></div>
                                    </div>
                                    <div className="flex gap-3">
                                        <div className="bg-green-100 p-2 rounded h-fit text-green-600"><IconCheck /></div>
                                        <div><h4 className="font-bold">Alinear Imágenes</h4><p>Al arrastrar una imagen, aparecerán <b>líneas fucsias</b> cuando se alinee perfectamente con los bordes o el centro de otras.</p></div>
                                    </div>
                                    <div className="flex gap-3">
                                        <div className="bg-purple-100 p-2 rounded h-fit text-purple-600"><IconLayers /></div>
                                        <div><h4 className="font-bold">Selección Múltiple</h4><p>Mantén presionada la tecla <b>Ctrl</b> mientras haces clic para seleccionar y editar varias imágenes a la vez.</p></div>
                                    </div>
                                    <div className="flex gap-3">
                                        <div className="bg-orange-100 p-2 rounded h-fit text-orange-600"><IconCrop /></div>
                                        <div><h4 className="font-bold">Recortar</h4><p>Selecciona una imagen y usa el botón "Recortar" en el menú izquierdo para ajustar el encuadre.</p></div>
                                    </div>
                                    <div className="flex gap-3">
                                        <div className="bg-teal-100 p-2 rounded h-fit text-teal-600"><IconUpload /></div>
                                        <div><h4 className="font-bold">Copiar y Pegar</h4><p>Puedes presionar <b>Ctrl+V</b> para pegar imágenes directamente desde el portapapeles.</p></div>
                                    </div>
                                    <div className="flex gap-3">
                                        <div className="bg-gray-100 p-2 rounded h-fit text-gray-600"><IconUndo /></div>
                                        <div><h4 className="font-bold">Deshacer</h4><p>Presiona <b>Ctrl+Z</b> para revertir la última acción.</p></div>
                                    </div>
                                    <div className="mt-4 pt-4 border-t text-center text-xs text-gray-400">
                                        Clic fuera de este cuadro para cerrar.
                                    </div>
                                </div>
                            </div>
                            <div className="absolute inset-0 -z-10" onClick={()=>setShowHelp(false)}></div>
                        </div>
                    )}

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>